## Выбор типа события: `input`

Выбор из `input`, `keydown`, `keyup` и `keypress`.

`input` работает при вставке мышью, например. Плюс работает при каждом срабатывании нажатой клавиши (в отличие от того же keyup, который сработает только когда клавишу отпустят; за это время в поле может попасть сколько угодно символов).  
Правда, у `input` нет никакой информации о том, какая клавиша была нажата.  
Кроме того, визуально `input` работает чуть менее понятно, чем `keyup`, в случае ввода недопустимых символов: в случае `keyup` такой символ ненадолго появляется в поле, в случае же `input` его не видно совсем.

Не `keypress`, т.к.:
> modifier and non-printing keys such as Shift, Esc, and delete trigger keydown events but 
not keypress events

(https://api.jquery.com/keypress/).

С `keyup` работать удобнее, чем с `keydown`, т.к. значение `input.value` отражает действие 
нажатых клавиш, в отличие от `keydown`.


## Пересечение кодов стран и определение применяемого шаблона

В случае, когда код одной страны совпадает с левой частью кода другой страны, важно, чтобы им обеим подходил один и тот же формат номера.

Есть всего один такой случай. Код `+1`: используется в оригинальном виде для США и Канады и в виде `+1XXX` для ряда небольших государств (`+1671` - Гуам, `+1939` - Пуэрто-Рико и др.). Во всех этих случаях вполне допустимо применять американский шаблон - `+1 (XXX) XXX-XXXX`, можно без скобок.
  
Есть также случай полного совпадения кодов стран: `+7` для России и Казахстана. В этом случае допустимо применять единый шаблон `+7 (XXX) XXX-XX-XX`, распространённый в России, либо шаблон без скобок, который также подойдет обеим странам.

Во всех остальных случаях полные коды страны не пересекаются.

Всё это позволяет ***однозначно определять применяемый шаблон на основании указанного в нём кода***.

Все коды можно посмотреть здесь: [Wikipedia: Телефонные коды стран](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BB%D0%B5%D1%84%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%B4%D1%8B_%D1%81%D1%82%D1%80%D0%B0%D0%BD).


## Почему не надо сразу дополнять первую введенную цифру остальными цифрами кода

Например, `+3` => `+375 `, и т.д.  
В таком случае при движении назад с удалением символов механизм не даст удалить символы из такой левой части, т.к. она автоматически будет "подскакивать" обратно. 


## Как быть с кодами городов длиной 4 и более символов

Например, `+7 (4832) 00-00-00`.

В столичном регионе острой необходимости в этом нет.

Самое простое - это сделать шаблон без скобок, чтобы хотя бы не так сильно разбивать код визуально.

Реальное решение задачи потребует:

* составления списка шаблонов для всех местных телефонных кодов;  
в России более 1000 одних только городов, количество местных телефонных зон (групп номеров, которые можно набирать без общей левой части; для большинства городов это 6- и 5-значные номера) может быть очень велико.

* определения шаблона с самой длинной частью среди
  конкурентных (чтобы из, например `+7 (`, `+7 (4832)` и `+7 (48341)` выбирался второй или третий).
  
Можно обойтись без второго пункта, если покрыть шаблонами всё пространство номеров ***без пересечений***.


## Особенности, не вошедшие в README

* если шаблон совпадает с телефоном до конца длины шаблона, дополнительные цифры, выходящие за пределы длины шаблона, вводить не разрешается

* если был ввод недопустимого символа и при этом курсор не был в конце, он будет сдвигаться вправо, т.к. мы сначала сохраняем позицию курсора, а потом применяем форматирование и удаляем недопустимые символы. 

* есть побочный эффект: не работает <kbd>Ctrl</kbd>+<kbd>Z</kbd>, т.к. значение поля   обновляется полностью

## Материалы по работе с курсором

https://www.vishalon.net/blog/javascript-getting-and-setting-caret-position-in-textarea  
Статья 2005 года, а предложенное решение работает до сих пор.  
Найдено на [форуме javascript.ru](https://javascript.ru/forum/misc/64-poziciya-kursora-v-input-type%3D-text-ie.html#post264)


## Почему важно сохранять позицию курсора при вводе

В противном случае при любом вводе курсор всегда будет прыгать в конец. Чтобы, например, 
заменить цифру в середине номера, нужно нажать <kbd>Del</kbd>/<kbd>Backspace</kbd>, затем 
вернуть убежавший в конец курсор и ввести собственно цифру; курсор снова прыгнет в конец, и если нужно заменить еще одну цифру, придется повторить всё это снова. Так происходит потому, что установка значения поля `input` всегда приводит к перемещению курсора в конец, и если не принять специальных мер против этого (как сделано в данной библиотеке), будут возникать вышеописанные неудобства.


## Почему к одному экземпляра объекта можно единовременно привязать только одно поле и один селектор

Потому что чтобы было иначе, нужно иметь хранилище объектов.

Чистый javascript не дает возможности:

* сохранять ссылку на объект в data-атрибуте

* использовать для типов событий пространства имен (типа `input.phoneFormatter`)

Всё это нужно, чтобы иметь возможность отключить слежение за полем/селектором.

В jQuery, например, эти возможности достигаются за счет специального хранилища этих сущностей, общего для всего документа, где используется jQuery.

В то же время, серьезной проблемой это не назовешь, потому что экземпляр объекта очень 
маленький, и его запросто можно создавать для каждого случая заново. 